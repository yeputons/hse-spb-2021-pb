Три штуки:
как думать про задачу и как там огребать,
тестирование и отладка,
как писать код, чтобы меньше огребать


Термины случайные

Доменная область/Задача. Обычно неформальная, непонятная. Проверка: общаемся с экспертами.
Формальное условие. Проверка: примеры. Обычно в олимпиадных задачах оно почти(!) есть.

Идея решения. Проверка: можно нарисовать. Не менять местами с составлением формального условия!

Декомпозиция: ввод/решение/вывод. Иногда добавляется генератор тестов. Может добавиться какая-нибудь структура данных (хэш-таблица).
+Контракты/структуры данных/представление данных. Проверка: написать на примерах.
Детали реализации/микроархитектура/инварианты. Проверка: написать на примерах.
Код

* Надо пройти все слои решения
* Частая проблема: решили задачу ("идея решения"), сразу начали писать код. Обнаружили баг, но пофиксили только в одном месте.
  Ну тут же быстро поправить!
  Примеры проблем: надо решать не за O(log), а за O(1). Или возникают вещественные числа. Или какое-то предположение неверно.
  Костыль: один if.
  Картинка: при написании кода мы концентрируемся на кусочке решения и не видим остальные.
  
  Ещё проблема: переполнение. Надо подумать, как бы его поправить.

* Основная алгоритмическая работа идёт до деталей реализации и инвариантов! Не код!
НОВОЕ: Лирическое отступление: Кто читал Гарри Поттера? Представим, что надо внести небольшое изменение: Вернон и Петунья теперь хорошие родители, любят и уважают Гарри. Что надо изменить? Они же редкие персонажи, возникают только летом (или нет?)

НОВОЕ: на самом деле в коде тоже много фишек: форматирование, опечатки, идиоматичное использование (range-based-for вместо for), имена переменных (должны соотноситься с инвариантами)

Каждый кусок надо отдельно: сформулировать, записать, показать связь с остальными кусочками. Протестировать, найти баги и несостыковки с остальными кусочками.

// ~10:00
Задача: VK Cup 2012 Квалификационный раунд 1 про папки: https://codeforces.com/contest/158/problem/C
Надо делать cd, pwd. Бывают абсолютные пути, а бывают относительные, бывает `..`.

Идеи:
* На самом деле у меня два разных cd: абсолютный и относительный
* Функции: init(), do_pwd(), do_cd() --> do_cd_absolute()/do_cd_relative(). Чтобы не путались переменные друг с другом.

Сложности:
* Пробелы в папках. Тут надо а) думать про ввод; б) думать про доменную область. На идею решения не влияет, при правильно выбранных способах взаимодействия всё тоже окей. А вот если бы мы разделили по пробелам, то упс (например, для stringstream).
* ??? Если хранить текущий путь как строчку и искать последнюю `/` при помощи цикла слева направо, то квадрат. 
* ??? Если нормализовывать только при pwd, а так конкатенация (и огребаем со слэшами, путаемся; сложный инвариант).
* ??? Пытаемся вырезать ./ и /. сразу (`foo./bar`), потом приходим к /./, но упс.
* ??? Пытаемся вырезать foo/.. сразу
* ??? Попытались добавить стресс-тестирование - не можем, потому что вывод захардкожен, можем только запустить отдельный процесс.
* ??? А если просто `cd` без аргумента?
* ??? cd абсолютный просто перезаписывает текущий путь
* ??? Симлинки — сразу FATALITY

Мораль:
* Проблемы лучше находить заранее.
* Выделяем отдельно ввод и вывод со структурами данных.
* Чем структурированнее данные — тем лучше. Получаются проще инварианты (пример со строчкой)

Как понять, что удобные структуры данных?
а) Попробовать написать код. Неприкольно.
б) Попробовать отладить код, который как бы написан. Посмотреть, какие значения принимают переменные.

Когда расписали и диаграмму данных между кусочками, и расписали их на примерах, у вас сразу при отладке есть референс.

Идеи: cd_abs = cd("/") + cd_rel . Это можно обнаружить при написании кода ("ой копипаст"), вернуться на уровень выше, отладить.

Отдельный кусочек: как разделить по слэшам? Первый слэш, последний? Ой? Ой. Инварианты упс.

С опытом вы всё это начнёте видеть сразу.

// Если делать сразу правильное решение: 25 минут

Общие случаи, не частные: http://blog.algoprog.ru/special-cases/

# Написание кода
http://blog.algoprog.ru/test-while-writing/

https://wiki.compscicenter.ru/index.php/%D0%9F%D0%B0%D1%80%D0%B0%D0%B4%D0%B8%D0%B3%D0%BC%D1%8B_1MIT,_%D0%A1%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D1%8B%D0%B5_%D0%B7%D0%B0%D0%BC%D0%B5%D1%87%D0%B0%D0%BD%D0%B8%D1%8F

Переменная "текущая сумма".

Переменные с названием m/mm.

## Видимость переменных
Концепция локальности.
Но если в цикле делаем break, то лучше сделать отдельную переменную "нашли чётный элемент".

## assert
Пишем cd: видим path[0], сразу ставим assert.
Другой пример: ищем минимальный элемент, надо в конце увидеть, что assert(min_index >= 0).
Замедление не больше обычных ифов.
Мой стандартный вопрос: а в этом месте верно? Поставьте ассёрт.

Можно сочетать со стресс-тестированием: проверили assert'ом, что у нас соглашается с наивным решением.

## Глобальные переменные и ввод-вывод
Лучше избавляться.
Проще тестировать: поставили assert(!рифма(палка, селёдка, 2)). В задаче про рифму.

## Структуры
Заведите! Структура "точка". Массив точек.

## 
Был пример
int a, b, c[100000];
cin >> a;
for (b = 0; b < a; b++) {
    cin >> c[b];
}
cout << c[0] + c[1];

Заводите массивы в точности нужного размера. А то ошибки заглушатся
Ассёрты (a >= 2) лучше ставить рядом с cout. 

# НОВОЕ: Инварианты
https://blog.algoprog.ru/init-not-clear/

Это про переменные в самом внутреннем месте. Жизнь ограничена итерацией.

# ~45:00: Тестирование и отладка 
https://notes.algoprog.ru/testing/06_testing_main.html

1. Примеры
2. Простые тесты. Про калькулятор. Общий случай.
3. Мин/макс тесты. Граничные! Упёрли одно условие. А ещё лучше два условия, pairwise testing. Упираем разные условия: вход, разнообразие, самый длинный/короткий ответ.
4. Красивые. Туэ-Морс, abacaba, все буквы a и одна b.
5. Случайные тесты. Творчески, что такое случайность.

Надо писать генераторы! Может быть надо обобщить задачу, чтобы было проще написать генератор.

Как ловить TL: локально макстест.

6. Регрессионные тесты.
Алгоритм при поимке бага: нашли баг, написали тест, придумали гипотезу, проверили гипотезу, разобрались. Только потом вернулись на уровень выше и поправили баг.
Поэтому лучше разделять решение на части: проще придумать тест на конкретную часть.

7. Все возможные тесты. Или все возможные маленькие тесты.
8. Притвориться, что вы допустили баг. Найти тест против него.

Надо на тестах запускать! Мультитест в олимпиадах, юнит-тесты на работе или на курсе по C++ (как один экзешник, у него есть фреймворк).

## Стресс-тестирование
Как ловить RTE: сгенерировали кучу тестов, запустили, программа не упала. С санитайзерами.
Как ловить WA: наивное решение (как можно меньше кусочков пересекается!) и проверили.

Есть проблемы: запуск процесса — дорого.

# Прочее (01:00)
`while (!eof)` писать нельзя нигде
Бинпоиск по коду. На самом деле это поиск лажающего элемента программы: мы просто смотрим на вывод после M итераций.
Если не компилируется, то тоже можно бинпоиск по коду. Но там сложнее зависимости.

Отладка в целом:
http://blog.algoprog.ru/how-to-debug-small-programs/
Фраза "что-то не работает". Expected/Got.
Материалы:
https://habr.com/ru/post/339038/
https://ru.stackoverflow.com/help/minimal-reproducible-example

Минимизация теста. Стрессом или как-то ещё. Бинпоиском по куску теста (но если граф, то упс, хотя по операциям норм).
На самом деле так делает QuickCheck.

Можно одновременно минимизировать тест и код, это норм.

Два вида вопросов: по алгоритмам (не сошлись данные), по коду/ЯП (эти строчки должны работать так, но работают так - обычно пример маленький, если нет бага в компиляторе).
Для багов в CLion тоже работает, в целом.
