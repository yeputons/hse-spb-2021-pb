Три штуки:
как думать про задачу и как там огребать,
тестирование и отладка,

Параллельно: как писать код, чтобы меньше огребать

# Как думать про программу
Термины случайные.

Порядок: 2, 3, 6, 5, 4, 6, 1.

1. Доменная область/Задача. Обычно неформальная, непонятная. Проверка: общаемся с экспертами.
2. Формальное условие. Проверка: примеры. Обычно в олимпиадных задачах оно почти(!) есть.
Пример: игра и проверить по логу

3. Идея решения. Проверка: можно нарисовать. Не менять местами с составлением формального условия!

4. Декомпозиция: ввод/решение/вывод. Иногда добавляется генератор тестов. Может добавиться какая-нибудь структура данных (хэш-таблица).
   +Контракты/структуры данных/представление данных. Проверка: написать на примерах.
5. Детали реализации/микроархитектура/инварианты. Проверка: написать на примерах.
6. Код

* Надо пройти все слои решения
* Частая проблема: решили задачу ("идея решения"), сразу начали писать код. Обнаружили баг, но пофиксили только в одном месте.
  Ну тут же быстро поправить!
  Примеры проблем: надо решать не за O(log), а за O(1). Или возникают вещественные числа. Или какое-то предположение неверно.
  Костыль: один if.
  Картинка: при написании кода мы концентрируемся на кусочке решения и не видим остальные.
  
  Ещё проблема: переполнение. Надо подумать, как бы его поправить.

* Основная алгоритмическая работа идёт до деталей реализации и инвариантов! Не код!

НОВОЕ: на самом деле в коде тоже много фишек: форматирование, опечатки, идиоматичное использование (range-based-for вместо for), имена переменных (должны соотноситься с инвариантами)

Каждый кусок надо отдельно: сформулировать, записать, показать связь с остальными кусочками. Протестировать, найти баги и несостыковки с остальными кусочками.

// ~10:00
Задача: VK Cup 2012 Квалификационный раунд 1 про папки: https://codeforces.com/contest/158/problem/C
Надо делать cd, pwd. Бывают абсолютные пути, а бывают относительные, бывает `..`.

Решение: храним текущий путь в строке, при абсолютном сбрасываем, при относительном сбрасываем точки слева, потом конкатенация.

Идеи:
* На самом деле у меня два разных cd: абсолютный и относительный
* Функции: init(), do_pwd(), do_cd() --> do_cd_absolute()/do_cd_relative(). Чтобы не путались переменные друг с другом.

Огребаем баги:
* WTF: слэши в конце пути дублируются. Реакция: надо удалить их в конце, а при конкатенации добавлять! Но тогда пустой путь `/`. Надо сложный инвариант.
* TL: Если хранить текущий путь как строчку и искать последнюю `/` при помощи цикла слева направо, то квадрат. 
  Можно локально поправить кусок кода, разбив путь по пробелам, заменив `/` на пробелы при помощи `stringstream`.
* WA: в абсолютных путях может встретиться `..`, давайте там тоже вырежем
* WTF: `cd` без аргументов?
* WTF: `..` в корне, надо ли сообщать об ошибке, игнорировать или сбрасывать в корень?
  Пусть надо об ошибке, исправили при выводе.
  * WA: нельзя нормализовывать относительный путь.
* WTF: папка `.` бывает? Да.
  * WA: Пытаемся вырезать ./ и /. сразу (`foo./bar`), потом приходим к /./, но упс.
* Пытаемся протестировать кусочек: не можем, потому что вывод захардкожен, можем только запустить отдельный процесс.
* WTF: Пробелы в папках. Тут надо а) думать про ввод; б) думать про доменную область. На идею решения не влияет, при правильно выбранных способах взаимодействия всё тоже окей.
* WTF: Симлинки — сразу FATALITY, потому что усложняется сразу идея решения.
  * Теперь может поменяться смысл даже `cd .`

Мораль:
* Проблемы лучше находить заранее.
* Выделяем отдельно ввод и вывод со структурами данных.
* Чем структурированнее данные — тем лучше. Получаются проще инварианты (пример со строчкой)
* Общие случаи, не частные: http://blog.algoprog.ru/special-cases/

Как понять, что удобные структуры данных?
а) Попробовать написать код. Неприкольно.
б) Попробовать отладить код, который как бы написан. Посмотреть, какие значения принимают переменные.

Когда расписали и диаграмму данных между кусочками, и расписали их на примерах, у вас сразу при отладке есть референс.

Идеи: cd_abs = cd("/") + cd_rel . Это можно обнаружить при написании кода ("ой копипаст"), вернуться на уровень выше, отладить.

С опытом вы всё это начнёте видеть сразу.

// Если делать сразу правильное решение: 25 минут

### Структуры
Заведите! Структура "точка". Массив точек.

## Инварианты
Отдельный кусочек: как разделить по слэшам? Первый слэш, последний? Ой? Ой. Инварианты упс. Даже если `stringstream`.

Плохой вариант:
```
vector<string> parts = {};
string current_directory = "";
for (int i = 0; i < s.size(); i++) {
    current_directory += s[i];
    if (s[i + 1] == '/') {
        parts.push_back(current_directory);
        current_directory = "";
    }
}
```

Хороший вариант, есть инвариант, всегда поддерживается, всегда можно остановить цикл:
```
vector<string> parts = {""};
for (int i = 0; i < s.size(); i++) {
    if (s[i] == '/') {
        parts.push_back("");
    } else {
        parts.back() += s[i];
    }
}
```
В таких split-задачах частый вопрос: а однозначно ли разделение?

### Переменные
https://wiki.compscicenter.ru/index.php/%D0%9F%D0%B0%D1%80%D0%B0%D0%B4%D0%B8%D0%B3%D0%BC%D1%8B_1MIT,_%D0%A1%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D1%8B%D0%B5_%D0%B7%D0%B0%D0%BC%D0%B5%D1%87%D0%B0%D0%BD%D0%B8%D1%8F

Переменная "текущая сумма".

Переменные с названием m/mm.

`while (!eof)` писать нельзя нигде

#### Видимость переменных
Концепция локальности.
Но если в цикле делаем break, то лучше сделать отдельную переменную "нашли чётный элемент".
https://blog.algoprog.ru/init-not-clear/

Это про переменные в самом внутреннем месте. Жизнь ограничена итерацией.

#### Глобальные переменные и ввод-вывод
Лучше избавляться.
Проще тестировать: поставили assert(!рифма(палка, селёдка, 2)). В задаче про рифму.

http://blog.algoprog.ru/test-while-writing/ - думайте про инварианты



# Тестирование и отладка
## ~45:00: Тестирование и отладка 
https://notes.algoprog.ru/testing/06_testing_main.html

1. Примеры
2. Простые/разные тесты. Про калькулятор. Общий случай. Все случаи: программа умеет выводить как такой ответ, так и такой.
   Если задача слегка различается для чётных и нечётных, пробуем оба.
3. Мин/макс тесты. Граничные!
   Упёрли одно условие. А ещё лучше два условия, pairwise testing. Упираем разные условия: вход, разнообразие, самый длинный/короткий ответ.
   Подлые сюда же.
4. Красивые. Туэ-Морс, abacaba, все буквы a и одна b.
5. Случайные тесты. Творчески, что такое случайность.

Надо писать генераторы! Может быть надо обобщить задачу, чтобы было проще написать генератор.

Как ловить TL: локально макстест.

6. Регрессионные тесты.
Алгоритм при поимке бага: нашли баг, написали тест, придумали гипотезу, проверили гипотезу, разобрались. Только потом вернулись на уровень выше и поправили баг.
Поэтому лучше разделять решение на части: проще придумать тест на конкретную часть.

7. Все возможные тесты. Или все возможные маленькие тесты.
8. Притвориться, что вы допустили баг. Найти тест против него.
   Какой-то иф перещёлкнулся.
   Если есть константа BUBEN - то попробовать разную.

Надо на тестах запускать! Мультитест в олимпиадах, юнит-тесты на работе или на курсе по C++ (как один экзешник, у него есть фреймворк).

## Стресс-тестирование
Как ловить RTE: сгенерировали кучу тестов, запустили, программа не упала. С санитайзерами.
Как ловить WA: наивное решение (как можно меньше кусочков пересекается!) и проверили.

Есть проблемы: запуск процесса — дорого.

## Прочее (01:00)
Бинпоиск по коду. На самом деле это поиск лажающего элемента программы: мы просто смотрим на вывод после M итераций.
Если не компилируется, то тоже можно бинпоиск по коду. Но там сложнее зависимости.

Отладка в целом:
http://blog.algoprog.ru/how-to-debug-small-programs/
Фраза "что-то не работает".
Два вида вопросов: по алгоритмам (не сошлись данные), по коду/ЯП (эти строчки должны работать так, но работают так - обычно пример маленький, если нет бага в компиляторе).
Для багов в CLion тоже работает.
Expected/Got.
Материалы:
https://habr.com/ru/post/339038/
https://ru.stackoverflow.com/help/minimal-reproducible-example

Минимизация теста. Стрессом или как-то ещё. Бинпоиском по куску теста (но если граф, то упс, хотя по операциям норм).
На самом деле так делает QuickCheck.

Можно одновременно минимизировать тест и код, это норм.

Для багов в CLion тоже работает, в целом.

# Написание кода
## assert
Пишем cd: видим path[0], сразу ставим assert.
Другой пример: ищем минимальный элемент, надо в конце увидеть, что assert(min_index >= 0).
Замедление не больше обычных ифов.
Мой стандартный вопрос: а в этом месте верно? Поставьте ассёрт.

Можно сочетать со стресс-тестированием: проверили assert'ом, что у нас соглашается с наивным решением.

## 
Был пример
int a, b, c[100000];
cin >> a;
for (b = 0; b < a; b++) {
    cin >> c[b];
}
cout << c[0] + c[1];

Заводите массивы в точности нужного размера. А то ошибки заглушатся
Ассёрты (a >= 2) лучше ставить рядом с cout. 
